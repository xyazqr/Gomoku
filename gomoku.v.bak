module gomoku(
    input        clk,
    input        rst,
    input        Btn0,

    // VGA
    output [3:0] VGA_R,     output [3:0] VGA_G,  output [3:0] VGA_B,
    output       VGA_HS,    output       VGA_VS,

    // Keypad
    output [3:0] KeyPadRow, input  [3:0] KeyPadCol,

    // Matrix1:落子狀態，Matrix2:贏家
    output [7:0] Dot1_row,  output [7:0] Dot1_col,
    output [7:0] Dot2_row,  output [7:0] Dot2_col,

    // 七段碼:0個位，1十位
    output [6:0] HEX0,      output [6:0] HEX1
);

    wire clkVGA, clkPad, clkDot, clkSevenSegment;
    wire key_valid;
    wire [3:0] key_code;

    wire place_en;
    wire [1:0] place_result;

    wire [3:0] cursor_row;
    wire [3:0] cursor_col;

    wire [1:0] current_player;
    wire [1:0] cell_data;

    wire [1:0] board_snapshot [0:15][0:15];

    wire win_flag;
    wire game_over;
    wire [1:0] winner;

    // turn timer (20s per turn)
    wire [4:0] turn_sec;
    wire timeout_pulse;
    wire turn_reset_pulse;

    wire [3:0] last_row;
    wire [3:0] last_col;
    wire [1:0] last_player;

    // clock divider
    freqDiv u_freqDiv(
        .clk(clk)       , .rst(rst),
        .clk_vga(clkVGA), .clk_keypad(clkPad),
        .clk_dot(clkDot), .clk_7seg(clkSevenSegment)
    );

    // keypad scanner
    checkPad u_checkPad(
        .clk_scan(clkPad),      .rst(rst),
        .keypadRow(KeyPadRow),  .keypadCol(KeyPadCol),
        .key_valid(key_valid),  .key_code(key_code)
    );

    // game controller (coordinate input + Btn0 confirm)
    game_fsm u_game_fsm(
        .clk(clk),              .rst(rst),
        .key_valid(key_valid),  .key_code(key_code),
        .btn0(Btn0),            .current_cell_data(cell_data),
        .win_in(win_flag),      .timeout_pulse(timeout_pulse),
        .place_en(place_en),    .place_result(place_result),
        .game_over(game_over),  .winner(winner),
        .turn_reset(turn_reset_pulse),
        .cursor_row(cursor_row),.cursor_col(cursor_col),
        .current_player(current_player),
        .last_row(last_row),    .last_col(last_col),
        .last_player(last_player)
    );

    turn_timer turn_timer (
        .clk(clk),                  .rst(rst),
        .enable(~game_over),        .reset_pulse(turn_reset_pulse),
        .sec_left(turn_sec),        .timeout_pulse(timeout_pulse)
    );

    // Seven-seg: show remaining seconds in decimal on HEX1(ten) HEX0(one)
    wire [3:0] sec_tens;
    wire [3:0] sec_ones;

    assign sec_tens = (turn_sec >= 5'd20) ? 4'd2 : (turn_sec >= 5'd10) ? 4'd1 : 4'd0;
    assign sec_ones = (sec_tens == 4'd2) ? (turn_sec - 5'd20) :
                      (sec_tens == 4'd1) ? (turn_sec - 5'd10) :
                                           turn_sec[3:0];

    sevenseg_digit u_7seg0(.digit(sec_ones), .seg(HEX0));
    sevenseg_digit u_7seg1(.digit(sec_tens), .seg(HEX1));

    // board memory
    board_mem u_board_mem(
        .clk(clk),
        .rst(rst),
        .write_en(place_en),
        .row(cursor_row),
        .col(cursor_col),
        .player(current_player),
        .cell_data(cell_data),
        .board(board_snapshot)
    );

    // win checker uses the *last placed* info (last_row/last_col/last_player)
    win_checker u_win(
        .board(board_snapshot),
        .last_x(last_row),
        .last_y(last_col),
        .player(last_player),
        .win(win_flag)
    );

    // VGA
    vga_display u_vga(
        .clk_vga(clkVGA),
        .rst(rst),
        .board(board_snapshot),
        .VGA_R(VGA_R),
        .VGA_G(VGA_G),
        .VGA_B(VGA_B),
        .VGA_HS(VGA_HS),
        .VGA_VS(VGA_VS)
    );

    dotmatrix_check dot1(
        .clk(clkDot),   .rst(rst),
        .place_result(place_result),
        .dot_row(Dot1_row), .dot_col(Dot1_col)
    );

    dotmatrix_winner dot2(
        .clk(clkDot),       .rst(rst),
        .game_over(game_over),  .winner(winner),
        .dot_row(Dot2_row),     .dot_col(Dot2_col)
    );

endmodule

// ============================================================
// KeyPad checker (scan 4x4)
// Mapping kept from the original file.
// ============================================================
module checkPad(
    input             clk_scan,
    input             rst,
    output reg [3:0]  keypadRow,
    input      [3:0]  keypadCol,
    output reg        key_valid,
    output reg [3:0]  key_code
);
    reg [1:0] row_index;

    always @(posedge clk_scan or negedge rst) begin
        if (!rst) begin
            row_index <= 2'd0;
            keypadRow <= 4'b1110;
            key_valid <= 1'b0;
            key_code  <= 4'd0;
        end else begin
            if (keypadCol != 4'b1111) begin
                key_valid <= 1'b1;
                case (keypadRow)
                    4'b1110: begin
                        if (!keypadCol[3]) key_code <= 4'h0;
                        else if (!keypadCol[2]) key_code <= 4'h1;
                        else if (!keypadCol[1]) key_code <= 4'h4;
                        else if (!keypadCol[0]) key_code <= 4'h7;
                    end
                    4'b1101: begin
                        if (!keypadCol[3]) key_code <= 4'hA;
                        else if (!keypadCol[2]) key_code <= 4'h2;
                        else if (!keypadCol[1]) key_code <= 4'h5;
                        else if (!keypadCol[0]) key_code <= 4'h8;
                    end
                    4'b1011: begin
                        if (!keypadCol[3]) key_code <= 4'hB;
                        else if (!keypadCol[2]) key_code <= 4'h3;
                        else if (!keypadCol[1]) key_code <= 4'h6;
                        else if (!keypadCol[0]) key_code <= 4'h9;
                    end
                    4'b0111: begin
                        if (!keypadCol[3]) key_code <= 4'hF;
                        else if (!keypadCol[2]) key_code <= 4'hE;
                        else if (!keypadCol[1]) key_code <= 4'hD;
                        else if (!keypadCol[0]) key_code <= 4'hC;
                    end
                endcase
            end else begin
                key_valid <= 1'b0;
            end

            row_index <= row_index + 2'd1;
            case (row_index + 2'd1)
                2'd0: keypadRow <= 4'b1110;
                2'd1: keypadRow <= 4'b1101;
                2'd2: keypadRow <= 4'b1011;
                2'd3: keypadRow <= 4'b0111;
            endcase
        end
    end
endmodule

module freqDiv(
    input  clk,
    input  rst,
    output reg clk_vga,
    output reg clk_keypad,
    output reg clk_dot,
    output reg clk_7seg
);

    reg [31:0] cnt_vga, cnt_keypad, cnt_dot, cnt_7seg;

    localparam VGA_EXP      = 32'd0;
    localparam KEYPAD_EXP   = 32'd249999;
    localparam DOT_EXP      = 32'd9999;
    localparam SEVENSEG_EXP = 32'd24999;

    always @(posedge clk or negedge rst) begin
        if (!rst) begin
            cnt_vga    <= 32'd0;
            cnt_keypad <= 32'd0;
            cnt_dot    <= 32'd0;
            cnt_7seg   <= 32'd0;
            clk_vga    <= 1'b0;
            clk_keypad <= 1'b0;
            clk_dot    <= 1'b0;
            clk_7seg   <= 1'b0;
        end else begin
            if (cnt_vga >= VGA_EXP) begin
                cnt_vga <= 32'd0;
                clk_vga <= ~clk_vga;
            end else cnt_vga <= cnt_vga + 32'd1;

            if (cnt_keypad >= KEYPAD_EXP) begin
                cnt_keypad <= 32'd0;
                clk_keypad <= ~clk_keypad;
            end else cnt_keypad <= cnt_keypad + 32'd1;

            if (cnt_dot >= DOT_EXP) begin
                cnt_dot <= 32'd0;
                clk_dot <= ~clk_dot;
            end else cnt_dot <= cnt_dot + 32'd1;

            if (cnt_7seg >= SEVENSEG_EXP) begin
                cnt_7seg <= 32'd0;
                clk_7seg <= ~clk_7seg;
            end else cnt_7seg <= cnt_7seg + 32'd1;
        end
    end
endmodule

// ============================================================
// Game FSM
// - capture 2 keypad keys => (row, col)
// - Btn0 confirm checks legality and places if possible
// ============================================================
module game_fsm(
    input        clk,
    input        rst,
    input        key_valid,
    input  [3:0] key_code,
    input        btn0,
    input  [1:0] current_cell_data,
    input        win_in,
    input        timeout_pulse,

    output reg        place_en,
    output reg [1:0]  place_result,
    output reg        game_over,
    output reg [1:0]  winner,
    output reg        turn_reset,

    output reg [3:0]  cursor_row,
    output reg [3:0]  cursor_col,
    output reg [1:0]  current_player,
    output reg [3:0]  last_row,
    output reg [3:0]  last_col,
    output reg [1:0]  last_player
);

    localparam P1 = 2'b01;
    localparam P2 = 2'b10;

    reg key_valid_prev;
    wire key_valid_pos_edge = key_valid & ~key_valid_prev;

    reg btn0_prev;
    wire btn0_pressed = (btn0_prev == 1'b1) && (btn0 == 1'b0);

    reg [1:0] input_count;
    reg [3:0] in_row;
    reg [3:0] in_col;

    reg pending_win_check;

    always @(posedge clk or negedge rst) begin
        if (!rst) begin
            current_player     <= P1;
            place_en           <= 1'b0;
            place_result       <= 2'b00;
            game_over          <= 1'b0;
            winner             <= 2'b00;
            turn_reset         <= 1'b0;
            cursor_row         <= 4'd0;
            cursor_col         <= 4'd0;
            last_row           <= 4'd0;
            last_col           <= 4'd0;
            last_player        <= 2'b00;
            key_valid_prev     <= 1'b0;
            btn0_prev          <= 1'b1;
            input_count        <= 2'd0;
            in_row             <= 4'd0;
            in_col             <= 4'd0;
            pending_win_check  <= 1'b0;
        end else begin
            place_en    <= 1'b0;
            turn_reset  <= 1'b0;

            key_valid_prev <= key_valid;
            btn0_prev      <= btn0;

            if (pending_win_check) begin
                pending_win_check <= 1'b0;
                if (win_in) begin
                    game_over <= 1'b1;
                    winner    <= last_player;
                end
            end

            if (!game_over) begin
                if (timeout_pulse) begin
                    current_player <= (current_player == P1) ? P2 : P1;
                    input_count    <= 2'd0;
                    place_result   <= 2'b00;
                    turn_reset     <= 1'b1;
                end else begin
                    if (key_valid_pos_edge) begin
                        if (input_count == 2'd0) begin
                            in_row      <= key_code;
                            input_count <= 2'd1;
                            cursor_row  <= key_code;
                        end else if (input_count == 2'd1) begin
                            in_col      <= key_code;
                            input_count <= 2'd2;
                            cursor_col  <= key_code;
                        end else begin
                            in_row      <= key_code;
                            in_col      <= 4'd0;
                            input_count <= 2'd1;
                            cursor_row  <= key_code;
                        end
                    end

                    if (btn0_pressed) begin
                        if (input_count == 2'd2) begin
                            if (current_cell_data == 2'b00) begin
                                place_en     <= 1'b1;
                                place_result <= 2'b01;

                                last_row     <= in_row;
                                last_col     <= in_col;
                                last_player  <= current_player;

                                current_player <= (current_player == P1) ? P2 : P1;
                                turn_reset     <= 1'b1;

                                pending_win_check <= 1'b1;
                            end else begin
                                place_result <= 2'b10;
                            end

                            input_count <= 2'd0;
                        end
                    end
                end
            end
        end
    end
endmodule

module board_mem(
    input   clk,    input   rst,
    input   write_en,
    input  [3:0] row,   input  [3:0] col,
    input  [1:0] player,    output [1:0] cell_data,
    output reg [1:0] board [0:15][0:15]
);

    integer i, j;
    assign cell_data = board[row][col];

    always @(posedge clk or negedge rst) begin
        if (!rst) begin
            for (i = 0; i < 16; i = i + 1)
                for (j = 0; j < 16; j = j + 1)
                    board[i][j] <= 2'b00;
        end else begin
            if (write_en) begin
                if (board[row][col] == 2'b00)
                    board[row][col] <= player;
            end
        end
    end
endmodule

module win_checker(
    input  [1:0] board [0:15][0:15],
    input  [3:0] last_x,    input  [3:0] last_y,
    input  [1:0] player,    output reg   win
);
    integer i;
    integer count;

    function integer in_range;
        input integer x;
        input integer y;
        begin
            in_range = (x >= 0 && x < 16 && y >= 0 && y < 16);
        end
    endfunction

    task automatic count_dir;
        input integer dx;
        input integer dy;
        integer k;
        integer cx;
        integer cy;
        integer stop;
        begin
            count = 1;

            stop = 0;
            for (k = 1; k < 5; k = k + 1) begin
                if (!stop) begin
                    cx = last_x + dx * k;
                    cy = last_y + dy * k;
                    if (in_range(cx, cy) && board[cx][cy] == player)
                        count = count + 1;
                    else
                        stop = 1;
                end
            end

            stop = 0;
            for (k = 1; k < 5; k = k + 1) begin
                if (!stop) begin
                    cx = last_x - dx * k;
                    cy = last_y - dy * k;
                    if (in_range(cx, cy) && board[cx][cy] == player)
                        count = count + 1;
                    else
                        stop = 1;
                end
            end
        end
    endtask

    always @(*) begin
        win = 1'b0;
        count = 0;

        if (player != 2'b00) begin
            count_dir(1, 0);
            if (count >= 5) win = 1'b1;

            if (!win) begin
                count_dir(0, 1);
                if (count >= 5) win = 1'b1;
            end

            if (!win) begin
                count_dir(1, 1);
                if (count >= 5) win = 1'b1;
            end

            if (!win) begin
                count_dir(1, -1);
                if (count >= 5) win = 1'b1;
            end
        end
    end
endmodule


// ============================================================
// VGA display (640x480@60)
// - draws 16x16 board in 480x480 area centered horizontally
// ============================================================
module vga_display(
    input  clk_vga,
    input  rst,
    input  [1:0] board [0:15][0:15],
    output reg [3:0] VGA_R,
    output reg [3:0] VGA_G,
    output reg [3:0] VGA_B,
    output reg       VGA_HS,
    output reg       VGA_VS
);

    localparam H_VISIBLE = 640;
    localparam H_FRONT   = 16;
    localparam H_SYNC    = 96;
    localparam H_BACK    = 48;
    localparam H_TOTAL   = 800;

    localparam V_VISIBLE = 480;
    localparam V_FRONT   = 10;
    localparam V_SYNC    = 2;
    localparam V_BACK    = 33;
    localparam V_TOTAL   = 525;

    reg [9:0] h_cnt;
    reg [9:0] v_cnt;

    wire visible = (h_cnt < H_VISIBLE) && (v_cnt < V_VISIBLE);

    localparam BOARD_SIZE = 480;
    localparam CELL_SIZE  = 30;
    localparam X0 = (H_VISIBLE - BOARD_SIZE) / 2;
    localparam Y0 = 0;

    function automatic [3:0] idx30;
        input [9:0] rel;
        integer k;
        integer found;
        begin
            idx30 = 4'd15;
            found = 0;
            for (k = 0; k < 16; k = k + 1) begin
                if (!found && (rel < (k+1)*CELL_SIZE)) begin
                    idx30 = k[3:0];
                    found = 1;
                end
            end
        end
    endfunction

    wire in_board = visible &&
                    (h_cnt >= X0) && (h_cnt < X0 + BOARD_SIZE) &&
                    (v_cnt >= Y0) && (v_cnt < Y0 + BOARD_SIZE);

    wire [9:0] rel_x = h_cnt - X0;
    wire [9:0] rel_y = v_cnt - Y0;

    wire [3:0] cell_c = idx30(rel_x);
    wire [3:0] cell_r = idx30(rel_y);

    wire [9:0] cell_x0 = cell_c * CELL_SIZE;
    wire [9:0] cell_y0 = cell_r * CELL_SIZE;
    wire [9:0] in_x = rel_x - cell_x0;
    wire [9:0] in_y = rel_y - cell_y0;

    wire [3:0] BG_R = 4'hD;
    wire [3:0] BG_G = 4'h9;
    wire [3:0] BG_B = 4'h4;

    localparam [3:0] GRID_R = 4'h0;
    localparam [3:0] GRID_G = 4'h0;
    localparam [3:0] GRID_B = 4'h0;

    localparam [3:0] BLACK_R = 4'h0;
    localparam [3:0] BLACK_G = 4'h0;
    localparam [3:0] BLACK_B = 4'h0;

    localparam [3:0] WHITE_R = 4'hF;
    localparam [3:0] WHITE_G = 4'hF;
    localparam [3:0] WHITE_B = 4'hF;

    localparam [3:0] W_BORDER_R = 4'hA;
    localparam [3:0] W_BORDER_G = 4'hA;
    localparam [3:0] W_BORDER_B = 4'hA;

    localparam [3:0] B_HILITE_R = 4'h3;
    localparam [3:0] B_HILITE_G = 4'h3;
    localparam [3:0] B_HILITE_B = 4'h3;

    wire grid_x = (in_x == 0);
    wire grid_y = (in_y == 0);

    wire grid_right  = (rel_x == (BOARD_SIZE-1));
    wire grid_bottom = (rel_y == (BOARD_SIZE-1));

    wire is_grid = grid_x || grid_y || grid_right || grid_bottom;

    wire [1:0] cell_val = board[cell_r][cell_c];

    localparam integer STONE_R  = 12;
    localparam integer STONE_R2 = STONE_R * STONE_R;
    localparam integer BORDER_R = 13;
    localparam integer BORDER_R2 = BORDER_R * BORDER_R;

    wire signed [10:0] dx = $signed({1'b0, in_x}) - 11'sd15;
    wire signed [10:0] dy = $signed({1'b0, in_y}) - 11'sd15;

    wire [21:0] dx2 = dx * dx;
    wire [21:0] dy2 = dy * dy;
    wire [22:0] dist2 = dx2 + dy2;

    wire stone_fill   = (dist2 <= STONE_R2);
    wire stone_border = (dist2 <= BORDER_R2) && (dist2 > STONE_R2);

    wire black_hilite = (stone_fill && (dx < 0) && (dy < 0) && (dist2 > (STONE_R2 - 40)));

    always @(posedge clk_vga or negedge rst) begin
        if (!rst) begin
            h_cnt <= 10'd0;
            v_cnt <= 10'd0;
        end else begin
            if (h_cnt == H_TOTAL-1) begin
                h_cnt <= 10'd0;
                if (v_cnt == V_TOTAL-1) v_cnt <= 10'd0;
                else v_cnt <= v_cnt + 10'd1;
            end else begin
                h_cnt <= h_cnt + 10'd1;
            end
        end
    end

    always @(*) begin
        VGA_HS = ~((h_cnt >= (H_VISIBLE + H_FRONT)) && (h_cnt < (H_VISIBLE + H_FRONT + H_SYNC)));
        VGA_VS = ~((v_cnt >= (V_VISIBLE + V_FRONT)) && (v_cnt < (V_VISIBLE + V_FRONT + V_SYNC)));
    end

    always @(*) begin
        VGA_R = 4'h0;
        VGA_G = 4'h0;
        VGA_B = 4'h0;

        if (visible) begin
            VGA_R = BG_R;
            VGA_G = BG_G;
            VGA_B = BG_B;

            if (in_board) begin
                if (cell_val != 2'b00 && (stone_fill || stone_border)) begin
                    if (cell_val == 2'b01) begin
                        if (stone_border) begin
                            VGA_R = B_HILITE_R;
                            VGA_G = B_HILITE_G;
                            VGA_B = B_HILITE_B;
                        end else if (black_hilite) begin
                            VGA_R = B_HILITE_R;
                            VGA_G = B_HILITE_G;
                            VGA_B = B_HILITE_B;
                        end else begin
                            VGA_R = BLACK_R;
                            VGA_G = BLACK_G;
                            VGA_B = BLACK_B;
                        end
                    end else begin
                        if (stone_border) begin
                            VGA_R = W_BORDER_R;
                            VGA_G = W_BORDER_G;
                            VGA_B = W_BORDER_B;
                        end else begin
                            VGA_R = WHITE_R;
                            VGA_G = WHITE_G;
                            VGA_B = WHITE_B;
                        end
                    end
                end
                else if (is_grid) begin
                    VGA_R = GRID_R;
                    VGA_G = GRID_G;
                    VGA_B = GRID_B;
                end
            end
        end
    end

endmodule

module dotmatrix_check(
    input   clk,    input   rst,
    input  [1:0] place_result,
    output reg [7:0] dot_row,   output reg [7:0] dot_col
);

    reg [2:0] row_index;
    reg [7:0] pattern;

    always @(*) begin
        pattern = 8'b00000000;
        if (place_result == 2'b01) begin
            case (row_index)
                3'd0:   pattern = 8'b00000001;
                3'd1:   pattern = 8'b00000010;
                3'd2:   pattern = 8'b00000100;
                3'd3:   pattern = 8'b10001000;
                3'd4:   pattern = 8'b01010000;
                3'd5:   pattern = 8'b00100000;
                default: pattern = 8'b00000000;
            endcase
        end else if (place_result == 2'b10) begin
            case (row_index)
                3'd0: pattern = 8'b10000001;
                3'd1: pattern = 8'b01000010;
                3'd2: pattern = 8'b00100100;
                3'd3: pattern = 8'b00011000;
                3'd4: pattern = 8'b00011000;
                3'd5: pattern = 8'b00100100;
                3'd6: pattern = 8'b01000010;
                3'd7: pattern = 8'b10000001;
            endcase
        end
    end

    always @(posedge clk or negedge rst) begin
        if (!rst) begin
            row_index <= 3'd0;
        end else begin
            row_index <= row_index + 3'd1;
        end
    end

    always @(*) begin
        dot_row = ~(8'b00000001 << row_index);
        dot_col = ~pattern;
    end
endmodule

module dotmatrix_winner(
    input   clk,       input        rst,
    input   game_over, input  [1:0] winner,
    output reg [7:0] dot_row,   output reg [7:0] dot_col
);

    reg [2:0] row_index;
    reg [7:0] pattern;

    always @(*) begin
        pattern = 8'b00000000;
        if (game_over) begin
            if (winner == 2'b01) begin
                case (row_index)
                    3'd0: pattern = 8'b00011000;
                    3'd1: pattern = 8'b00111000;
                    3'd2: pattern = 8'b00011000;
                    3'd3: pattern = 8'b00011000;
                    3'd4: pattern = 8'b00011000;
                    3'd5: pattern = 8'b00011000;
                    3'd6: pattern = 8'b00111100;
                    3'd7: pattern = 8'b00000000;
                endcase
            end else if (winner == 2'b10) begin
                case (row_index)
                    3'd0: pattern = 8'b00111100;
                    3'd1: pattern = 8'b01000010;
                    3'd2: pattern = 8'b00000100;
                    3'd3: pattern = 8'b00001000;
                    3'd4: pattern = 8'b00010000;
                    3'd5: pattern = 8'b00100000;
                    3'd6: pattern = 8'b01111110;
                    3'd7: pattern = 8'b00000000;
                endcase
            end
        end
    end

    always @(posedge clk or negedge rst) begin
        if (!rst)
            row_index <= 3'd0;
        else
            row_index <= row_index + 3'd1;
    end

    always @(*) begin
        dot_row = ~(8'b00000001 << row_index);
        dot_col = ~pattern;
    end
endmodule

module sevenseg_digit(input  [3:0] digit, output reg [6:0] seg);
    always @(*) begin
        case (digit)
            4'd0: seg = 7'b1000000;
            4'd1: seg = 7'b1111001;
            4'd2: seg = 7'b0100100;
            4'd3: seg = 7'b0110000;
            4'd4: seg = 7'b0011001;
            4'd5: seg = 7'b0010010;
            4'd6: seg = 7'b0000010;
            4'd7: seg = 7'b1111000;
            4'd8: seg = 7'b0000000;
            4'd9: seg = 7'b0010000;
            default: seg = 7'b1111111;
        endcase
    end
endmodule

module turn_timer(
    input        clk,           input        rst,
    input        enable,        input        reset_pulse,
    output reg [4:0] sec_left,  output reg   timeout_pulse
);
    localparam integer secClock = 50000000;
    localparam [4:0] second = 5'd20;
    reg [31:0] count;

    always @(posedge clk or negedge rst) begin
        if (!rst) begin
            count <= 32'b0;
            sec_left <= second;
            timeout_pulse <= 1'b0;
        end else begin
            timeout_pulse <= 1'b0;
            if (reset_pulse) begin
                count <= 32'b0;
                sec_left <= second;
            end else if (enable) begin
                if (count == (secClock-1)) begin
                    count <= 32'b0;
                    if (sec_left != 5'd0) begin
                        sec_left <= sec_left - 5'd1;
                        if (sec_left == 5'd1) begin
                            timeout_pulse <= 1'b1;
                        end
                    end
                end else begin
                    count <= count + 32'b1;
                end
            end
        end
    end
endmodule
